\section{QA-Prolog}
\begin{frame}{QA-Prolog}
	\begin{minipage}{.48\linewidth}
		\begin{block}{Il progetto}
			\begin{itemize}
				\item Sviluppato da Sott Pakin
				\item Proof of concept
				\item Trasformazioni successive
				\item Prolog + Query $\rightarrow \mathcal{H}_f$  
				\item Interagisce direttamente con il solver
				\item Raccoglie e organizza i risultati
			\end{itemize}
		\end{block}
	\end{minipage}
	\hfill
	\begin{minipage}{.48\linewidth}
		\begin{figure}
			\includegraphics[width=.7\linewidth]{Pakin}
			\caption{Scott Pakin - Los Alamos National Laboratory}
		\end{figure}
	\end{minipage}
\end{frame}


\begin{frame}{Pipeline}
	\begin{minipage}{.48\linewidth}
		immagine
	\end{minipage}
	\hfill
	\begin{minipage}{.48\linewidth}
		\begin{block}{Trasformazioni}
			\begin{enumerate}
				\item Prolog $\rightarrow$ Verilog (HDL)
				\item Verilog $\rightarrow$ Circuito digitale
				\item Circuito digitale $\rightarrow$ $\mathcal{H}_f$ simbolica 
				\item $\mathcal{H}_f$ simbolica  $\rightarrow$ $\mathcal{H}_f$ fisica 
			\end{enumerate}
		\end{block}
	\end{minipage}
\end{frame}


\begin{frame}{QMASM}{$\mathcal{H}_f$ simbolica  $\rightarrow$ $\mathcal{H}_f$ fisica}
		\begin{minipage}{.48\linewidth}
			\begin{block}{Cos'è}
				\begin{itemize}
					\item Quantum macro assembler
					\item Sviluppato in Python
					\item Basso livello di astrazione
					\item Si interfaccia con Ocean
				\end{itemize}
			\end{block}
		\end{minipage}
		\hfill
		\begin{minipage}{.48\linewidth}
			\begin{block}{Cosa permette di fare}
				\begin{itemize}
					\item Riferimento simbolico a \emph{qubit}
					\item \emph{Qubit} \say{pinnati} a \texttt{TRUE} o \texttt{FALSE}
					\item Incapsulare pattern in macro
					\item Creazione di librerie di macro
					\item Pulizia dell'output:
					\begin{itemize}
						\item solo \emph{qubit} \say{interessanti}
						\item no slack variables
					\end{itemize}
				\end{itemize}
			\end{block}
		\end{minipage}
\end{frame}


\begin{frame}[fragile]{QMASM}{Esempio: Macro}
	\begin{minipage}{.3\linewidth}
		\begin{figure}[h]
			\begin{minipage}{\linewidth}
				\hrule
				\begin{minted}{text}
					
# Y = A OR B
!begin_macro OR
  $A  0.5
  $B  0.5
  $Y -1

  $A $B  0.5
  $A $Y -1
  $B $Y -1
!end_macro OR
				\end{minted}
				\hrule
			\end{minipage}
			\caption{\textbf{or} gate}
		\end{figure}
	\end{minipage}
	\hfill
	\begin{minipage}{.3\linewidth}
		\begin{figure}[h]
			\begin{minipage}{\linewidth}
				\hrule
				\begin{minted}{text}

# Y = NOT A
!begin_macro NOT
  $A $Y 1.0
!end_macro NOT
				\end{minted}
				\hrule
			\end{minipage}
			\caption{\textbf{not} gate}
		\end{figure}
	\end{minipage}
	\hfill
	\begin{minipage}{.3\linewidth}
		\begin{figure}[h]
			\begin{minipage}{\linewidth}
				\hrule
				\begin{minted}{text}
					
# Y = A AND B
!begin_macro AND
  $A -0.5
  $B -0.5
  $Y  1

  $A $B  0.5
  $A $Y -1
  $B $Y -1
!end_macro AND
				\end{minted}
				\hrule
			\end{minipage}
			\caption{\textbf{and} gate}
		\end{figure}
	\end{minipage}
	\begin{block}{}
		\centering
		possiamo racchiudere queste macro nel file \texttt{gates.qmasm}
	\end{block}
\end{frame}

\begin{frame}[fragile]{QMASM}{Esempio: $y = x_1 \land \neg(x_2 \lor x_3)$}
	\begin{center}
	\begin{minipage}{.25\linewidth}
		\begin{figure}[h]
			\begin{minipage}{\linewidth}
				\hrule
				\begin{minted}{text}
					
!include <gates>

!use_macro OR x2_or_x3
x2_or_x3.$A = x2
x2_or_x3.$B = x3
x2_or_x3.$Y = $x4

!use_macro NOT not_x4
not_x4.$A = $x4
not_x4.$Y = $x5

!use_macro AND x1_and_x5
x1_and_x5.$A = x1
x1_and_x5.$B = $x5
x1_and_x5.$Y = y
				\end{minted}
				\hrule
			\end{minipage}
			\caption{CircSat problem}
		\end{figure}
	\end{minipage}
	\hspace{1cm}
	\begin{minipage}{.6\linewidth}
		\begin{block}{}
			\say{Pinniamo} il valore di $y$ per ottenere l'assegnamento delle $x_i$ che verificano la formula logica:
			\begin{center}
				\scriptsize \texttt{qmasm --run --pin="y := true" circsat.qmasm}
			\end{center}
		\end{block}
		\begin{figure}[h]
			\centering
			\begin{minipage}{.72\linewidth}
				\hrule
				\begin{minted}{text}
					
Solution #1 (energy = -20.0000, tally = 647):

    Variable  Value
    --------  -----
    x1        True
    x2        False
    x3        False
    y         True
				\end{minted}
				\hrule
			\end{minipage}
			\caption{CircSat solution}
		\end{figure}
	\end{minipage}
	\end{center}
\end{frame}


\begin{frame}[fragile]{Yosys - edif2qmasm}
	\begin{block}{}
		\centering
		Verilog $\rightarrow$ Circuito digitale $\rightarrow \mathcal{H}$ simbolica 
	\end{block}
\begin{minipage}{\linewidth}
	\begin{minipage}{.48\linewidth}
		\begin{block}{Yosys}
			\begin{itemize}
				\item Framework per la sintesi del Verilog
				\item Free and open software sotto licenza ISC
				\item Output: RTL Netlist in formato EDIF
			\end{itemize}
		\end{block}
	\end{minipage}
	\hfill
	\begin{minipage}{.48\linewidth}
		\begin{block}{edif2qmasm}
			\begin{itemize}
				\item Converte dal formato EDIF a QMASM
				\item Attinge a una libreria di gate
			\end{itemize}
		\end{block}
	\end{minipage}
\end{minipage}
\begin{figure}
	\begin{minipage}{.65\linewidth}
		\includegraphics[width=.47\linewidth]{sat_circ.pdf}
		\hfill
		\includegraphics[width=.47\linewidth]{sat_net.pdf}
	\end{minipage}
	\hfill
	\begin{minipage}{.3\linewidth}
		\begin{minted}{text}
			
!begin_macro sat
  !use_macro AND $id00004
  !use_macro OR $id00003
  $id00003.A = b
  $id00003.B = c
  $id00004.A = a
  $id00004.B = $id00003.Y
  $id00004.Y = y
!end_macro sat
		\end{minted}
	\end{minipage}
\end{figure}
\end{frame}


\begin{frame}[fragile]{Yosys - edif2qmasm}{Esempio: moltiplicazione tra interi}
		\begin{minipage}{.48\linewidth}
			\begin{figure}[h]
				\begin{minipage}{\linewidth}
					\hrule
					\begin{minted}{Verilog}
					
module mult (multiplicand, multiplier, product);
   input [1:0] multiplicand;
   input [1:0] multiplier;
   output[2:0] product;

   assign product = multiplicand * multiplier;
endmodule
					\end{minted}
					\hrule
				\end{minipage}
			\caption{Factorization problem}
		\end{figure}
		\vspace{-.7cm}
		\begin{block}{Traduzione in EDIF}
			\begin{center}
				\scriptsize \texttt{yosys myfile.v synth.ys -b edif -o myfile.edif}
			\end{center}
		\end{block}
		\begin{block}{Traduzione in QMASM}
			\begin{center}
				\scriptsize \texttt{edif2qmasm -o="myfile.qmasm" myfile.edif}
			\end{center}
		\end{block}
	\end{minipage}
	\hfill
	\begin{minipage}{.48\linewidth}
		\begin{block}{Esecuzione}
			\begin{center}
				\scriptsize \texttt{qmasm --run --pin="mult.product[2:0] := 110" --solver="sim\_anneal" mult.qmasm}
			\end{center}
		\end{block}
		\vspace{-.1cm}
			\begin{figure}[h]
				\begin{minipage}{.9\linewidth}
					\hrule
					\begin{minted}{text}
					
Solution #1 (energy = -57.5000, tally = 68):

    Variable              Value
    --------------------  -----
    mult.multiplicand[0]  False
    mult.multiplicand[1]  True
    mult.multiplier[0]    True
    mult.multiplier[1]    True
    mult.product[0]       False
    mult.product[1]       True
    mult.product[2]       True
					\end{minted}
					\hrule
				\end{minipage}
			\caption{Factorization Solution}
		\end{figure}
	\end{minipage}
\end{frame}


\begin{frame}[fragile]{QA-Prolog}
	\begin{minipage}{.48\linewidth}
		\begin{block}{}
			\begin{itemize}
				\item Traduzione da Prolog a Verilog
				\item Wrapper per tutta la Pipeline
				\item Risultati in formato Human Readable
				\item Decide dimensione delle variabili
			\end{itemize}
		\end{block}
	\end{minipage}
	\hfill
	\begin{minipage}{.48\linewidth}
		\begin{figure}[h]
			\begin{minipage}{.9\linewidth}
				\hrule
				\begin{minted}{Prolog}

sat(A, B, C, Y) :-
    or(B, C, X),
    not(X, Z),
    and(A, Z, Y).
				\end{minted}
				\hrule
			\end{minipage}
			\caption{Prolog Code}
		\end{figure}
		\begin{figure}[h]
			\begin{minipage}{.9\linewidth}
				\hrule
				\begin{minted}{Verilog}

module sat (a, b, c, y);
   input a, b, c;
   output y;

   assign y = a & ~(b | c);
endmodule
				\end{minted}
				\hrule
			\end{minipage}
			\caption{Verilog Code}
		\end{figure}
	\end{minipage}
\end{frame}


\begin{frame}[fragile]{QA-Prolog}{Esempio}
	\begin{minipage}{.48\linewidth}
		\begin{block}{Base di conoscenza}
			Il nemico del mio nemico è mio amico
		\end{block}
		\begin{figure}[h]
			\begin{minipage}{\linewidth}
				\hrule
				\begin{minted}{Prolog}
					
hates(alice, bob).
hates(bob, charlie).

enemies(P, Q) :- hates(P, Q).
enemies(P, Q) :- hates(Q, P).

friends(A, B) :-
	enemies(A, X),
	enemies(X, B),
	A \= B.
				\end{minted}
				\hrule
			\end{minipage}
			\caption{Enemy of my Enemy}
		\end{figure}
	\end{minipage}
	\hfill
	\begin{minipage}{.48\linewidth}
		\begin{block}{Esecuzione}
			\begin{center}
				\scriptsize \texttt{QA-Prolog --qmasm-args="--postproc=opt" --query='friends(P1, P2).' friends.pl}
			\end{center}
		\end{block}
			\begin{figure}[h]
				\begin{minipage}{.3\linewidth}
					\hrule
					\begin{minted}{text}
					
P1 = alice
P2 = charlie

P1 = charlie
P2 = alice
					\end{minted}
					\hrule
				\end{minipage}
			\caption{Query Solution}
		\end{figure}
	\end{minipage}
\end{frame}


\begin{frame}[fragile]{Update al progetto}
	\begin{minipage}{.42\linewidth}
		\begin{block}{Integrazione con Ocean}
			\begin{itemize}
				\item Aggiornamento librerie obsolete
				\item Rimozione metodi deprecati
				\item Sostituzione funzioni \say{spostate}
				\item Correzione parametri funzioni
			\end{itemize}
		\end{block}
		\begin{block}{Altro}
			\begin{itemize}
				\item Sostituzione funzioni rinominate
				\item Parametri command line
			\end{itemize}
		\end{block}
	\end{minipage}
	\hfill
	\begin{minipage}{.55\linewidth}
		\begin{figure}
			\begin{minipage}{.9\linewidth}
				\hrule
				\begin{minted}{python}

#from dwave.cloud import Client, hybrid, qpu, sw
from dwave.cloud import Client
import hybrid

#from greedy import SteepestDescentSolver
from dwave.samplers import SteepestDescentSolver

#from tabu import TabuSampler
from dwave.samplers import TabuSampler

#from scipy.stats import median_absolute_deviation
from scipy.stats import median_abs_deviation
				\end{minted}
				\hrule
			\end{minipage}
			\caption{Update librerie}
		\end{figure}
		\vspace{-.5cm}
		\begin{figure}
			\begin{minipage}{.9\linewidth}
				\hrule
				\begin{minted}{python}

#elif solver == "neal":
elif solver == "sim_anneal":
				\end{minted}
				\hrule
				\caption{Correzione parametri command line}
			\end{minipage}
		\end{figure}
	\end{minipage}
\end{frame}

\begin{frame}[fragile]{Update al progetto}{Incompatibilità tra output edif2qmasm e input QMASM}
	\begin{minipage}{.31\linewidth}
		\begin{figure}
			\begin{minipage}{.95\linewidth}
				\hrule
				\begin{minted}{verilog}

// Define hates(atom, atom).
module \hates/2 (A, B, Valid);
	...
endmodule
				\end{minted}
				\hrule
			\end{minipage}
			\caption{Verilog}
		\end{figure}
		\vspace{-.6cm}
		\begin{figure}
			\begin{minipage}{.95\linewidth}
				\hrule
				\begin{minted}{text}

# hates/2
!begin_macro id00011
	...
!end_macro id00011

# enemies/2
!begin_macro id00010
  !use_macro OR $id00031
  !use_macro hates/2
  ...
				\end{minted}
				\hrule
				\caption{qmasm}
			\end{minipage}
		\end{figure}
	\end{minipage}
	\hfill
	\begin{minipage}{.67\linewidth}
		\begin{figure}
			\begin{minipage}{.95\linewidth}
				\hrule
				\begin{minted}{python}

with open(file, 'r') as input:
	first = input.readline()
	second = input.readline()
	while(second_row != ""):
		if first.startswith("#") and second.startswith("!begin_macro"):
			self.name[first[2:-1]] = second[len("!begin_macro "):-1]
		first_row = second_row
		second_row = input.readline()

with open(file, 'r') as input:
	doc = input.read()
	lines = doc.splitlines()
	for line in lines:
		for word in line.split():
			if word in self.name.keys():
				line = line.replace(word, self.name[word])
		self.new_lines.append(line)
				\end{minted}
				\hrule
			\end{minipage}
			\caption{Preprocessing}
		\end{figure}
	\end{minipage}
\end{frame}